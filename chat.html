<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chat</title>

<style>
body {
  margin: 0;
  font-family: Arial, sans-serif;
  background: white;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

#chat-header {
  position: sticky;
  top: 0;
  background: white;
  border-bottom: 1px solid #ddd;
  padding: 14px 18px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  z-index: 10;
}

#left-box {
  display: flex;
  align-items: center;
  gap: 12px;
}

#back-btn {
  font-size: 22px;
  cursor: pointer;
  user-select: none;
}

#profile-pic {
  width: 46px;
  height: 46px;
  border-radius: 50%;
  background: black;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}

#center-info {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
}

#chat-username {
  font-size: 16px;
  font-weight: bold;
}

#chat-id {
  font-size: 12px;
  color: #555;
}

#chat-body {
  flex: 1;
  padding: 14px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  overflow-x: hidden;
}

.message {
  max-width: 75%;
  min-width: 60%;
  padding: 10px;
  margin-bottom: 8px;
  border-radius: 8px;
  font-size: 14px;
  position: relative;
}

.sent {
  background: black;
  color: white;
  margin-left: auto;
}

.received {
  background: #eee;
  color: black;
}
.message::before,
.poll-wrapper::before {
  content: "";
  display: block;
  min-height: 17px;
}
.message-text {
  white-space: pre-wrap;      /* preserves \n AND wraps */
  word-wrap: break-word;      /* legacy */
  overflow-wrap: break-word;  /* modern */
}

#chat-input {
  position: sticky;
  bottom: 0;
  background: white;
  border-top: 1px solid #ddd;
  padding: 12px;
  display: flex;
  gap: 8px;
}

#messageInput {
  flex: 1;
  padding: 10px;
  font-size: 15px;
  border: 1px solid #ccc;
  border-radius: 6px;
  resize: none;
  overflow-y: auto;
  line-height: 1.4;
  max-height: 120px;
  overflow-x: hidden;
}

#sendBtn {
  padding: 10px 16px;
  border: none;
  background: black;
  color: white;
  font-size: 14px;
  border-radius: 6px;
}

/* POLL STYLES */
.poll-wrapper {
  width: 75%;              /* match .message max-width */
  min-width: 250px;
  padding: 10px 12px;
  border-radius: 8px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  position: relative;
  margin: 8px 0;
  cursor: default;
  transition: background 0.2s;
}

/* Sent vs Received Alignment */
.poll-wrapper.sent {
  align-self: flex-end;    /* right side */
  background: black;
  color: white;
}

.poll-wrapper.received {
  align-self: flex-start;  /* left side */
  background: #eee;
  color: black;
}

/* Poll content */
.poll-question {
  font-weight: bold;
  margin-bottom: 12px;
  font-size: 14px;
}

.poll-option {
  margin-bottom: 12px;
  cursor: pointer;
}

.poll-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.poll-circle {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  border: 2px solid #aaa;
  transition: 0.2s;
}

.poll-circle.selected {
  background: #2196f3;
  border-color: #2196f3;
}

.poll-text {
  font-size: 14px;
}

.poll-bar-container {
  width: 100%;
  height: 6px;
  background: #222;
  border-radius: 6px;
  overflow: hidden;
  margin-top: 4px;
}

.poll-bar {
  height: 100%;
  width: 0;
  background: #2196f3;
  transition: width 0.35s ease;
}

.poll-status {
  font-size: 11px;
  opacity: 0.6;
  position: absolute;
  bottom: 6px;
  right: 10px;
}
.message-meta {
  font-size: 11px;
  opacity: 0.6;
  margin-top: 4px;
  display: flex;
  justify-content: flex-end;
  gap: 6px;
}

.message.received .message-meta {
  justify-content: flex-start;
}
.date-divider {
  text-align: center;
  margin: 12px 0;
  font-size: 12px;
  color: #666;
  position: relative;
}

.date-divider::before,
.date-divider::after {
  content: "";
  position: absolute;
  top: 50%;
  width: 30%;
  height: 1px;
  background: #ddd;
}

.date-divider::before {
  left: 0;
}

.date-divider::after {
  right: 0;
}
/* REPLY PREVIEW */
#reply-preview {
  position: sticky;
  bottom: 60px;
  background: #f1f1f1;
  border-top: 1px solid #ddd;
  padding: 10px 14px;
  font-size: 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  animation: slideUp 0.2s ease;
}

#reply-text {
  max-width: 85%;
  color: #333;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#close-reply {
  font-size: 18px;
  cursor: pointer;
  padding-left: 10px;
}

/* animation */
@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Swipe indicator (optional feedback) */
.message {
  transition: transform 0.2s ease;
}
.reply-bubble {
  background: #eee;
  padding: 6px 10px;
  border-left: 3px solid #2196f3;
  border-radius: 6px;
  font-size: 13px;
  color: #333;
  margin-bottom: 4px;
  max-width: 90%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.sent .reply-bubble {
  background: #333;
  color: #fff;
  border-left-color: #2196f3;
}
.read-toggle {
  color: #2196f3;
  font-weight: bold;
  cursor: pointer;
  margin-top: 6px;
  display: inline-block;
}

.read-toggle:hover {
  text-decoration: underline;
}
/* Glow/flash for linked messages on tap */
.highlight-message {
  animation: megaGlow 2s ease-out 1;
}

@keyframes megaGlow {
  0% {
    box-shadow:
      0 0 0 4px #1e88e5,
      0 0 25px 10px rgba(30,136,229,1),
      0 0 50px 18px rgba(30,136,229,0.9),
      0 0 80px 30px rgba(30,136,229,0.7);
  }
  100% { box-shadow: none; }
}
/* ===== MULTI SELECT ===== */

.message.selected,
.poll-wrapper.selected {
  opacity: 0.55; /* faint like WhatsApp */
}

/* reuse your glow */
.message.selected.highlight-message,
.poll-wrapper.selected.highlight-message {
  animation: megaGlow 2s ease-out 1;
}
#selection-board {
  position: sticky; /* sticks to top */
  top: 0;
  left: 0;
  right: 0;
  height: 60px;
  background: white; /* board background */
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 12px;
  z-index: 20; /* above chat header */
  font-family: Arial, sans-serif;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#board-back-btn {
  font-size: 22px;
  cursor: pointer;
  user-select: none;
}

#board-title {
  font-size: 16px;
  font-weight: bold;
}
/* ===== SELECTION BOARD DELETE BUTTON ===== */
#board-delete-btn {
  margin-left: auto;           /* pushes it to the far right */
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 0.3px;

  border-radius: 20px;
  border: 1px solid #e53935;

  color: #e53935;
  background: rgba(229, 57, 53, 0.08);

  cursor: pointer;
  user-select: none;

  transition: all 0.2s ease;
}

/* hover / active feedback */
#board-delete-btn:hover {
  background: #e53935;
  color: white;
}

#board-delete-btn:active {
  transform: scale(0.96);
}
/* ===== DELETE MODAL ===== */
#delete-modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

/* Modal box */
.delete-box {
  width: 90%;
  max-width: 320px;
  background: white;
  border-radius: 14px;
  padding: 18px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  animation: popIn 0.15s ease;
}

/* shared button style */
.delete-option,
.delete-cancel {
  padding: 12px;
  font-size: 15px;
  font-weight: 600;
  border-radius: 10px;
  border: none;
  cursor: pointer;
}

/* Option 1 */
.delete-me {
  background: white;
  color: black;
  border: 1px solid #ddd;
}

/* Option 2 */
.delete-everyone {
  background: white;
  color: #e53935;
  border: 1px solid #e53935;
}

/* Cancel */
.delete-cancel {
  background: #e53935;
  color: black;
}

/* subtle animation */
@keyframes popIn {
  from {
    transform: scale(0.95);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}
#message-menu {
  position: absolute;
  background: white;
  border-radius: 8px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.15);
  font-size: 14px;
  z-index: 100;
  overflow: hidden;
}

.menu-item {
  padding: 10px 14px;
  cursor: pointer;
}

.menu-item:hover {
  background: #f1f1f1;
}
.deleted-for-everyone {
  font-style: italic;
  color: #999;
  text-align: center;
  pointer-events: none; /* prevents menu on deleted messages */
}

.deleted-text {
  font-style: italic;
  color: #999;
  font-size: 0.9em;
}
</style>
</head>

<body>

<div id="chat-header">
  <div id="left-box">
    <div id="back-btn" onclick="goBack()">←</div>
    <div id="profile-pic"></div>
  </div>
  <div id="center-info">
    <div id="chat-username">Username</div>
    <div id="chat-id">ID</div>
  </div>
</div>
<!-- SELECTION MODE BOARD -->
<div id="selection-board" style="display:none;">
  <div id="board-back-btn">←</div>

  <div id="board-title">Selection Mode</div>

  <!-- ADD THIS -->
  <div id="board-delete-btn">
    Delete
  </div>
</div>

<!-- DELETE OPTIONS MODAL -->
<div id="delete-modal" style="display:none;">
  <div class="delete-box">

    <button class="delete-option delete-me">
      Delete for me
    </button>

    <button class="delete-option delete-everyone">
      Delete for everyone
    </button>

    <button class="delete-cancel">
      Cancel
    </button>

  </div>
</div>
<div id="message-menu" style="display:none;">
  <div class="menu-item" id="menu-reply">Reply</div>
  <div class="menu-item" id="menu-select">Select</div>
</div>

<div id="chat-body"></div>
<!-- MESSAGE PREVIEW -->
<div id="reply-preview" style="display:none;">
  <div id="reply-text"></div>
  <span id="close-reply">✕</span>
</div>

<div id="chat-input">
  <textarea id="messageInput" placeholder="Type a message..." rows="1"></textarea>
  <button id="sendBtn">Send</button>
</div>

<script>
const API_URL = "https://fweb-backend.onrender.com/fchat";
const account = JSON.parse(localStorage.getItem("faccount")) || {};
const chatWith = JSON.parse(localStorage.getItem("chatting_with")) || {};

if (!chatWith || !chatWith.id) {
  alert("No chat selected");
  window.location.href = "fchat.html";
}
// Message Storage
const STORAGE_KEY = `chat_${account.email}_${chatWith.id}`;
let messages = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
let selectionMode = false;
const selectedMessages = new Set();
let longPressTimer = null;

const FCHAT_STORAGE_KEY = `fchat_messages_${account.email}`;
let fchatMessages = JSON.parse(localStorage.getItem(FCHAT_STORAGE_KEY)) || [];

// Header
document.getElementById("chat-username").textContent = chatWith.username || "User";
document.getElementById("chat-id").textContent = "ID: " + (chatWith.id || "");

const profilePic = document.getElementById("profile-pic");
if (chatWith.profile_pic) {
  profilePic.style.backgroundImage = `url('${chatWith.profile_pic}')`;
  profilePic.style.backgroundSize = "cover";
  profilePic.style.backgroundPosition = "center";
} else {
  profilePic.textContent = (chatWith.username || "U").split(" ").map(w => w[0]).join("").toUpperCase();
}

// Chat body
const chatBody = document.getElementById("chat-body");

// Date dividers
function formatDateLabel(dateStr) {
  const date = new Date(dateStr);
  const today = new Date();
  const yesterday = new Date();
  yesterday.setDate(today.getDate() - 1);

  const isSameDay = (d1, d2) =>
    d1.getFullYear() === d2.getFullYear() &&
    d1.getMonth() === d2.getMonth() &&
    d1.getDate() === d2.getDate();

  if (isSameDay(date, today)) return "Today";
  if (isSameDay(date, yesterday)) return "Yesterday";

  return date.toLocaleDateString(undefined, {
    year: "numeric",
    month: "short",
    day: "numeric"
  });
}
// Toggle Selection Mode
function toggleSelectMessage(el, msgObj) {
  const id = msgObj.id;

  if (selectedMessages.has(id)) {
    selectedMessages.delete(id);
    el.classList.remove("selected", "highlight-message");
  } else {
    selectedMessages.add(id);
    el.classList.add("selected", "highlight-message");
  }

  // enter selection mode if at least one message selected
  selectionMode = selectedMessages.size > 0;

  // Refresh the selection board visibility
  updateSelectionBoard();
}

// Selection board elements
const selectionBoard = document.getElementById("selection-board");
const boardBackBtn = document.getElementById("board-back-btn");
const deleteForMeBtn = document.querySelector(".delete-me");
const deleteForEveryoneBtn = document.querySelector(".delete-everyone");
const messageMenu = document.getElementById("message-menu");
const menuReply = document.getElementById("menu-reply");
const menuSelect = document.getElementById("menu-select");

let menuTargetMsg = null;
let menuTargetEl = null;

// Hide menu when clicking elsewhere
document.addEventListener("click", () => {
  messageMenu.style.display = "none";
});

// ===== DELETE FOR ME =====
deleteForMeBtn.addEventListener("click", () => {
  if (selectedMessages.size === 0) return;

  // 1️⃣ Delete from chat-specific messages (UI source)
  messages = messages.filter(
    msg => !selectedMessages.has(msg.id)
  );
  localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));

  // 2️⃣ Delete from global fchat messages
  fchatMessages = fchatMessages.filter(
    msg => !selectedMessages.has(msg.id)
  );
  localStorage.setItem(FCHAT_STORAGE_KEY, JSON.stringify(fchatMessages));

  // 3️⃣ Remove from DOM
  selectedMessages.forEach(id => {
    const msgEl = chatBody.querySelector(`[data-id='${id}']`);
    if (msgEl) msgEl.remove();
  });

  // 4️⃣ Cleanup
  selectedMessages.clear();
  selectionMode = false;
  updateSelectionBoard();

  // 5️⃣ Close modal
  deleteModal.style.display = "none";
});

// Show/hide the selection board based on selection
function updateSelectionBoard() {
  if (selectionMode) {
    selectionBoard.style.display = "flex";
    const boardTitle = document.getElementById("board-title");
    boardTitle.textContent = ""; // static, no count
  } else {
    selectionBoard.style.display = "none";
  }
}
// ===== DELETE FOR EVERYONE =====
deleteForEveryoneBtn.addEventListener("click", () => {
  if (selectedMessages.size === 0) return;

  const jsonToSend = {
    action: "delete_for_everyone",
    chat_id: chatWith.id,
    message_ids: Array.from(selectedMessages),
    requested_by: account.id,
    timestamp: Date.now()
  };

  // Send to backend
  fetch(API_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(jsonToSend)
  })
  .then(res => res.json())
  .then(res => console.log("Delete for everyone response:", res))
  .catch(err => console.error(err));

  // Update frontend immediately
  selectedMessages.forEach(id => {
    const msgEl = chatBody.querySelector(`[data-id='${id}']`);
    if (msgEl) {
      msgEl.classList.add("deleted-for-everyone");
      msgEl.innerHTML = `<i class="deleted-text">This message was deleted by you</i>`;
    }
  });

  // Cleanup
  selectedMessages.clear();
  selectionMode = false;
  updateSelectionBoard();
  deleteModal.style.display = "none";
});

// Back button cancels selection mode
boardBackBtn.onclick = () => {
  clearSelection();
};

// ===== DELETE MODAL LOGIC =====
const deleteModal = document.getElementById("delete-modal");
const deleteBtn = document.getElementById("board-delete-btn");
const cancelDeleteBtn = document.querySelector(".delete-cancel");

// Open delete form
deleteBtn.addEventListener("click", (e) => {
  e.stopPropagation(); // prevent selection clear
  deleteModal.style.display = "flex";
});

// Cancel closes modal
cancelDeleteBtn.addEventListener("click", () => {
  deleteModal.style.display = "none";
});

// Clicking outside the box closes modal
deleteModal.addEventListener("click", (e) => {
  if (e.target === deleteModal) {
    deleteModal.style.display = "none";
  }
});

// Tapping anywhere on chat background also cancels selection mode
chatBody.addEventListener("click", () => {
  if (selectionMode) clearSelection();
});

// Helper to clear all selections
function clearSelection() {
  selectedMessages.forEach(id => {
    const msgEl = chatBody.querySelector(`[data-id='${id}']`);
    if (msgEl) msgEl.classList.remove("selected", "highlight-message");
  });

  selectedMessages.clear();
  selectionMode = false;
  updateSelectionBoard();
}
// Menu For PC
menuReply.onclick = () => {
  if (!menuTargetMsg) return;

  showReplyPreview(menuTargetMsg);
  messageMenu.style.display = "none";
};

menuSelect.onclick = () => {
  if (!menuTargetMsg || !menuTargetEl) return;

  selectionMode = true;
  toggleSelectMessage(menuTargetEl, menuTargetMsg);

  messageMenu.style.display = "none";
};
// Add message function
function addMessage(msgObj) {
  const msg = document.createElement("div");
  msg.dataset.id = msgObj.id;

  const isSent = String(msgObj.sender_id) === String(account.id);
  const alignmentClass = isSent ? "sent" : "received";

  // Format time
  const time = new Date(msgObj.sent_at).toLocaleTimeString([], {
    hour: "2-digit",
    minute: "2-digit"
  });

  if (msgObj.isPoll && msgObj.pollData) {
    msg.className = `poll-wrapper ${alignmentClass}`;
    msg.innerHTML = `
      <div class="poll-question">${msgObj.pollData.question}</div>

      ${msgObj.pollData.options.map((opt, i) => `
        <div class="poll-option" data-index="${i}">
          <div class="poll-row">
            <div class="poll-circle"></div>
            <div class="poll-text">${opt}</div>
          </div>
          <div class="poll-bar-container">
            <div class="poll-bar"></div>
          </div>
        </div>
      `).join("")}

      <div class="message-meta">
        ${time} ${isSent ? "• " + (msgObj.status || "sent") : ""}
      </div>
    `;
  } else {
  msg.className = `message ${alignmentClass}`;

let replyHTML = "";
if (msgObj.replyTo) {
  replyHTML = `
    <div class="reply-bubble">
      ${msgObj.replyTo.text}
    </div>
  `;
}

// ✅ Handle deleted-for-everyone
if (msgObj.deleted && msgObj.deleted_for === "everyone") {
  msg.innerHTML = `
    ${replyHTML}
    <i class="deleted-text">
      This message was deleted by ${msgObj.requested_by === account.id ? "you" : "someone"}
    </i>
    <div class="message-meta">
      ${time}
    </div>
  `;
} else {
  msg.innerHTML = `
    ${replyHTML}
    <div class="message-text"></div>
    <div class="message-meta">
      ${time} ${isSent ? "• " + (msgObj.status || "sent") : ""}
    </div>
  `;
  const textBox = msg.querySelector(".message-text");
  applyReadMore(textBox, msgObj.text);
}

  enableSwipe(msg, msgObj); // full object
// Glow ONLY when clicking the reply preview bubble
if (msgObj.linked) {
  const replyBubble = msg.querySelector(".reply-bubble");
  if (!replyBubble) return;

  replyBubble.style.cursor = "pointer";

  replyBubble.addEventListener("click", (e) => {
    e.stopPropagation(); // ⛔ clicking bubble won't trigger message click

    const linkedMsgId = msgObj.linked_message_id;
    const originalMsg = chatBody.querySelector(
      `[data-id='${linkedMsgId}']`
    );
    if (!originalMsg) return;

    let cancelScroll = false;

    const stopScroll = () => { cancelScroll = true; };
    document.addEventListener("click", stopScroll, {
      once: true,
      capture: true
    });

    const startScrollTop = chatBody.scrollTop;
    const targetTop =
      originalMsg.offsetTop -
      chatBody.offsetHeight / 2 +
      originalMsg.offsetHeight / 2;

    const duration = 400;
    const startTime = performance.now();

    function easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    function smoothScroll(currentTime) {
      if (cancelScroll) return;

      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      chatBody.scrollTop =
        startScrollTop +
        (targetTop - startScrollTop) * easeInOutQuad(progress);

      if (progress < 1) {
        requestAnimationFrame(smoothScroll);
      } else {
        triggerGlow();
      }
    }

    function triggerGlow() {
      originalMsg.classList.remove("highlight-message");
      void originalMsg.offsetWidth;
      originalMsg.classList.add("highlight-message");
    }

    requestAnimationFrame(smoothScroll);
  });
}
}
  chatBody.appendChild(msg);
// Desktop right-click menu
msg.addEventListener("contextmenu", e => {
  e.preventDefault(); // ⛔ disable browser menu

  if (selectionMode) return;
  if (e.pointerType === "touch") return;

  e.stopPropagation();

  menuTargetMsg = msgObj;
  menuTargetEl = msg;

  const rect = msg.getBoundingClientRect();
  const isSent = msg.classList.contains("sent");

  messageMenu.style.top =
    window.scrollY + rect.top + rect.height / 2 + "px";

  if (isSent) {
    messageMenu.style.left = rect.left - 120 + "px";
  } else {
    messageMenu.style.left = rect.right + 10 + "px";
  }

  messageMenu.style.display = "block";
});
  // ===== LONG PRESS MULTI SELECT =====
msg.addEventListener("touchstart", e => {
  if (e.target.closest(".reply-bubble")) return; // don't hijack reply clicks

  longPressTimer = setTimeout(() => {
    selectionMode = true;
    toggleSelectMessage(msg, msgObj);
  }, 400);
});

msg.addEventListener("touchend", () => {
  clearTimeout(longPressTimer);
});

msg.addEventListener("touchmove", () => {
  clearTimeout(longPressTimer);
});

// Tap behavior when selection mode is active
msg.addEventListener("click", e => {
  if (!selectionMode) return;

  e.stopPropagation();
  toggleSelectMessage(msg, msgObj);
});
  chatBody.scrollTop = chatBody.scrollHeight;
}
// Update timeline
function updateTimeline() {
  chatBody.innerHTML = "";

  const chatItems = fchatMessages
    .filter(m => m.receiver_id === chatWith.id || m.sender_id === chatWith.id)
    .sort((a, b) => new Date(a.sent_at) - new Date(b.sent_at));

  let lastDate = null;

  chatItems.forEach(msg => {
    const msgDate = new Date(msg.sent_at).toDateString();

    if (msgDate !== lastDate) {
      const dateDivider = document.createElement("div");
      dateDivider.className = "date-divider";
      dateDivider.textContent = formatDateLabel(msg.sent_at);
      chatBody.appendChild(dateDivider);

      lastDate = msgDate;
    }

    addMessage(msg);
  });
}
// Read more, Read less logic
function applyReadMore(container, fullText) {
  const lines = fullText.split("\n");
  const MAX_LINES = 15;
  const STEP = 30;

  if (lines.length <= MAX_LINES) {
    container.innerHTML = fullText.replace(/\n/g, "<br>");
    return;
  }

  let visibleLines = MAX_LINES;

  function render() {
    const shown = lines.slice(0, visibleLines).join("<br>");
    container.innerHTML = shown;

    const toggle = document.createElement("span");
    toggle.className = "read-toggle";

    if (visibleLines < lines.length) {
      toggle.textContent = " Read more";
      toggle.onclick = () => {
        visibleLines = Math.min(visibleLines + STEP, lines.length);
        render();
      };
    } else {
      toggle.textContent = " Read less";
      toggle.onclick = () => {
        visibleLines = MAX_LINES;
        render();
      };
    }

    container.appendChild(toggle);
  }

  render();
}
// Sync messages
function syncToFChat(msgObj=null) {
  if(msgObj && !fchatMessages.some(fm => fm.id === msgObj.id)) fchatMessages.push(msgObj);
  else messages.forEach(m => { if(!fchatMessages.some(fm=>fm.id===m.id)) fchatMessages.push(m); });

  fchatMessages.sort((a,b) => new Date(a.sent_at)-new Date(b.sent_at));
  localStorage.setItem(FCHAT_STORAGE_KEY, JSON.stringify(fchatMessages));
  updateTimeline();
}

// Sync polls
function syncPolls() {
  const POLL_STORAGE_KEY = `polls_${account.email}_${chatWith.id}`;
  const polls = JSON.parse(localStorage.getItem(POLL_STORAGE_KEY)) || [];

  polls.forEach(p => {
    if(!fchatMessages.some(fm => fm.id===p.id)) {
      fchatMessages.push({
        id: p.id,
        type: "sent",
        isPoll: true,
        pollData: p.pollData,
        status: p.status,
        sender_id: p.sender_id,
        receiver_id: chatWith.id,
        sent_at: p.sent_at
      });
    }
  });

  fchatMessages.sort((a,b)=>new Date(a.sent_at)-new Date(b.sent_at));
  localStorage.setItem(FCHAT_STORAGE_KEY, JSON.stringify(fchatMessages));
}

// Send message
async function sendToBackend(msgObj) {
  try {
    const payload = {
      action: "send_messages",
      email: account.email,
      id: msgObj.id,
      sender_id: account.id,
      receiver_id: chatWith.id,
      linked: msgObj.linked,
      linked_message_id: msgObj.linked_message_id,
      sent_at: msgObj.sent_at,
      text: msgObj.text
    };

    const res = await fetch(API_URL, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    msgObj.status = data.success ? "sent" : "pending";
  } catch(e) {
    msgObj.status = "pending";
    console.warn("Failed to send", e);
  }

  localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
  syncToFChat(msgObj);
}

let replyingMessage = null;

function sendMessage() {
  const input = document.getElementById("messageInput");
  const text = input.value.trim();
  if (!text) return;

  const msgObj = {
    id: Date.now(),
    type: "sent",
    text,
    sent_at: new Date().toISOString(),
    status: navigator.onLine ? "sending" : "pending",
    sending_since: navigator.onLine ? Date.now() : null,
    replyTo: replyingMessage
      ? {
          id: replyingMessage.id,
          text:
            replyingMessage.text?.slice(0, 120) +
            (replyingMessage.text?.length > 120 ? "…" : ""),
          sender: replyingMessage.sender_id
        }
      : null,
    linked: replyingMessage ? true : false, // yes/no field
    linked_message_id: replyingMessage ? replyingMessage.id : null,
    sender_id: account.id,
    receiver_id: chatWith.id
  };

  messages.push(msgObj);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
  syncToFChat(msgObj);

  input.value = "";
  input.style.height = "auto";
  replyingMessage = null;

  if (navigator.onLine) sendToBackend(msgObj);

  // hide reply preview
  document.getElementById("reply-preview").style.display = "none";
}

document.getElementById("sendBtn").onclick = sendMessage;

function goBack(){ window.location.href="fchat.html"; }

let startX = 0;
let currentMessage = null;

function enableSwipe(messageEl, msgObj) {
  messageEl.addEventListener("touchstart", e => { startX = e.touches[0].clientX; });
  messageEl.addEventListener("touchmove", e => {
    const diff = e.touches[0].clientX - startX;
    if (diff > 40) messageEl.style.transform = "translateX(25px)";
  });
  messageEl.addEventListener("touchend", e => {
    const diff = e.changedTouches[0].clientX - startX;
    if (diff > 60) showReplyPreview(msgObj); // pass full object
    messageEl.style.transform = "translateX(0)";
  });
}

function showReplyPreview(msgObj) {
  const preview = document.getElementById("reply-preview");
  const previewText = document.getElementById("reply-text");

  previewText.textContent = msgObj.text?.slice(0, 120) || "";
  preview.style.display = "flex";

  // THIS IS CRUCIAL:
  replyingMessage = msgObj; // ✅ now sendMessage knows this is linked
}
// Close preview
document.getElementById("close-reply").onclick = () => {
  document.getElementById("reply-preview").style.display = "none";
};

const textarea = document.getElementById("messageInput");

textarea.addEventListener("input", () => {
  textarea.style.height = "auto";
  textarea.style.height = Math.min(textarea.scrollHeight, 120) + "px";
});
// Initial load
syncPolls();
syncToFChat();
</script>

</body>
</html>